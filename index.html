<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Texas Hold'em — Práctica sin instalación</title>
  <style>
    :root {
      color-scheme: light;
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: #f1f5f9;
      color: #0f172a;
    }
    body {
      margin: 0;
      padding: 2rem;
      display: flex;
      justify-content: center;
    }
    h1 {
      text-align: center;
      margin-bottom: 0.5rem;
    }
    .app {
      width: min(920px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    .card {
      background: white;
      border-radius: 18px;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.15);
      border: 1px solid rgba(148, 163, 184, 0.35);
      padding: 1.5rem;
    }
    .panel-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.75rem;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    button {
      background: #059669;
      color: white;
      border: none;
      border-radius: 999px;
      padding: 0.65rem 1.4rem;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(5, 150, 105, 0.2);
      transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }
    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 14px 26px rgba(5, 150, 105, 0.28);
      filter: brightness(1.05);
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      box-shadow: none;
    }
    .secondary {
      background: white;
      color: #0f172a;
      border: 1px solid rgba(100, 116, 139, 0.4);
      box-shadow: none;
    }
    .secondary:hover:not(:disabled) {
      box-shadow: 0 10px 20px rgba(100, 116, 139, 0.18);
    }
    .layout {
      display: grid;
      gap: 1.5rem;
    }
    @media (min-width: 900px) {
      .layout {
        grid-template-columns: 2fr 1fr;
      }
    }
    .hole, .board, .opponent {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .playing-card {
      width: 72px;
      height: 108px;
      border-radius: 20px;
      background: white;
      border: 2px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 10px;
      box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.2);
      font-weight: 700;
      font-size: 1.3rem;
    }
    .playing-card.red {
      color: #dc2626;
      border-color: rgba(248, 113, 113, 0.65);
    }
    .card-back {
      width: 72px;
      height: 108px;
      border-radius: 20px;
      background: linear-gradient(135deg, #0f172a, #1e3a8a);
      color: white;
      display: grid;
      place-items: center;
      font-size: 2rem;
      letter-spacing: 0.1em;
      border: 2px solid rgba(148, 163, 184, 0.45);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15);
    }
    .tag {
      display: inline-flex;
      padding: 0.25rem 0.65rem;
      border-radius: 999px;
      font-size: 0.75rem;
      background: rgba(15, 118, 110, 0.1);
      color: #0f766e;
      font-weight: 600;
    }
    .message {
      font-size: 1rem;
      min-height: 1.5rem;
      color: #1f2937;
    }
    .log {
      font-size: 0.9rem;
      line-height: 1.6;
      color: #475569;
    }
    ul {
      padding-left: 1.2rem;
    }
    footer {
      font-size: 0.75rem;
      color: #64748b;
      text-align: center;
    }
  </style>
</head>
<body>
  <main class="app">
    <header class="card">
      <h1>Texas Hold'em — práctica inmediata</h1>
      <p class="log">
        Este archivo HTML contiene toda la aplicación. Guarda el fichero y ábrelo con tu navegador favorito para practicar una partida
        simplificada de Texas Hold'em sin instalar dependencias ni ejecutar comandos.
      </p>
    </header>

    <section class="card">
      <div class="panel-title">Acciones</div>
      <div class="actions">
        <button id="deal-btn">Nueva mano</button>
        <button id="next-btn" class="secondary" disabled>Siguiente fase</button>
        <button id="showdown-btn" class="secondary" disabled>Mostrar ganador</button>
      </div>
      <p class="message" id="message">Pulsa «Nueva mano» para empezar.</p>
    </section>

    <section class="layout">
      <section class="card">
        <div class="panel-title">Mesa</div>
        <div class="tag" id="phase-tag">Fase: –</div>
        <h2>Cartas comunitarias</h2>
        <div class="board" id="board"></div>
        <h2>Tus cartas</h2>
        <div class="hole" id="hero-hole"></div>
        <h2>Oponente</h2>
        <div class="opponent" id="villain-hole"></div>
      </section>

      <section class="card">
        <div class="panel-title">Detalle de la mano</div>
        <div class="log" id="hand-log"></div>
        <hr style="margin: 1.5rem 0; border: none; border-top: 1px solid rgba(148, 163, 184, 0.35);">
        <div>
          <div class="panel-title">Cómo funciona</div>
          <ul>
            <li>Reparte una mano nueva y avanza por las fases: preflop, flop, turn y river.</li>
            <li>En el show-down se revela la mano del oponente y se calcula automáticamente el ganador.</li>
            <li>El algoritmo evalúa todas las combinaciones posibles de 5 cartas para determinar la mejor jugada.</li>
          </ul>
        </div>
      </section>
    </section>

    <footer>Creado para ejecutarse directamente: no necesitas Node, npm ni servidores locales.</footer>
  </main>

  <script>
    const PHASES = ["Preflop", "Flop", "Turn", "River", "Showdown"];
    const RANKS = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
    const SUITS = ["♠","♥","♦","♣"];
    const RANK_VALUE = Object.fromEntries(RANKS.map((r, i) => [r, i]));

    const CAT = {
      HIGH: 0,
      PAIR: 1,
      TWOPAIR: 2,
      TRIPS: 3,
      STRAIGHT: 4,
      FLUSH: 5,
      FULL: 6,
      QUADS: 7,
      STRAIGHTFLUSH: 8,
    };

    const CATEGORY_LABEL = {
      [CAT.HIGH]: "Carta alta",
      [CAT.PAIR]: "Pareja",
      [CAT.TWOPAIR]: "Doble pareja",
      [CAT.TRIPS]: "Trío",
      [CAT.STRAIGHT]: "Escalera",
      [CAT.FLUSH]: "Color",
      [CAT.FULL]: "Full",
      [CAT.QUADS]: "Póker",
      [CAT.STRAIGHTFLUSH]: "Escalera de color",
    };

    const state = {
      deck: [],
      hero: [],
      villain: [],
      board: [],
      phase: -1,
      showdown: false,
    };

    const dealBtn = document.getElementById("deal-btn");
    const nextBtn = document.getElementById("next-btn");
    const showdownBtn = document.getElementById("showdown-btn");
    const messageEl = document.getElementById("message");
    const phaseTag = document.getElementById("phase-tag");
    const boardEl = document.getElementById("board");
    const heroEl = document.getElementById("hero-hole");
    const villainEl = document.getElementById("villain-hole");
    const logEl = document.getElementById("hand-log");

    dealBtn.addEventListener("click", startHand);
    nextBtn.addEventListener("click", advancePhase);
    showdownBtn.addEventListener("click", revealWinner);

    function startHand() {
      state.deck = createDeck();
      shuffle(state.deck);
      state.hero = [state.deck.pop(), state.deck.pop()];
      state.villain = [state.deck.pop(), state.deck.pop()];
      state.board = [];
      for (let i = 0; i < 5; i++) {
        state.board.push(state.deck.pop());
      }
      state.phase = 0;
      state.showdown = false;
      updatePhase();
      render();
      logEl.textContent = "";
      messageEl.textContent = "Selecciona “Siguiente fase” para revelar el flop.";
      nextBtn.disabled = false;
      showdownBtn.disabled = true;
    }

    function advancePhase() {
      if (state.phase < PHASES.length - 1) {
        state.phase += 1;
        updatePhase();
        render();
        if (state.phase === PHASES.length - 1) {
          messageEl.textContent = "Listo para el show-down.";
          nextBtn.disabled = true;
          showdownBtn.disabled = false;
        } else {
          const nextPhase = PHASES[state.phase + 1];
          messageEl.textContent = `Has pasado a ${PHASES[state.phase]}. Pulsa de nuevo para llegar a ${nextPhase}.`;
        }
      }
    }

    function revealWinner() {
      if (state.showdown) {
        return;
      }
      state.showdown = true;
      render();
      const heroScore = bestOfSeven([...state.hero, ...state.board]);
      const villainScore = bestOfSeven([...state.villain, ...state.board]);
      const cmp = compareScore(heroScore, villainScore);
      const heroLabel = scoreLabel(heroScore);
      const villainLabel = scoreLabel(villainScore);
      let summary;
      if (cmp > 0) {
        summary = `¡Ganas la mano! ${heroLabel} contra ${villainLabel}.`;
      } else if (cmp < 0) {
        summary = `Pierdes la mano. ${villainLabel} vence a ${heroLabel}.`;
      } else {
        summary = `Empate. Ambos jugadores muestran ${heroLabel}.`;
      }
      messageEl.textContent = summary;
      logEl.innerHTML = `
        <p><strong>Tu jugada:</strong> ${heroLabel}</p>
        <p><strong>Oponente:</strong> ${villainLabel}</p>
        <p>Evaluación realizada comparando las mejores combinaciones posibles de 5 cartas entre las 7 disponibles.</p>
      `;
      showdownBtn.disabled = true;
    }

    function updatePhase() {
      const phaseName = state.phase >= 0 ? PHASES[state.phase] : "–";
      phaseTag.textContent = `Fase: ${phaseName}`;
    }

    function render() {
      renderCards(heroEl, state.hero);
      const villainCards = state.showdown ? state.villain : [null, null];
      renderCards(villainEl, villainCards);

      let boardCount = 0;
      if (state.phase >= 1) boardCount = 3;
      if (state.phase >= 2) boardCount = 4;
      if (state.phase >= 3 || state.showdown) boardCount = 5;
      const visibleBoard = state.showdown ? state.board : state.board.slice(0, boardCount);
      boardEl.innerHTML = "";
      visibleBoard.forEach(card => boardEl.appendChild(createCard(card)));

      if (!visibleBoard.length) {
        boardEl.innerHTML = '<p style="color:#94a3b8">Todavía no hay cartas comunitarias.</p>';
      }

      if (!state.hero.length) {
        heroEl.innerHTML = '<p style="color:#94a3b8">Pulsa «Nueva mano».</p>';
        villainEl.innerHTML = '<p style="color:#94a3b8">—</p>';
      }
    }

    function renderCards(container, cards) {
      container.innerHTML = "";
      cards.forEach(card => {
        if (card) {
          container.appendChild(createCard(card));
        } else {
          const back = document.createElement("div");
          back.className = "card-back";
          back.textContent = "🂠";
          container.appendChild(back);
        }
      });
    }

    function createCard(card) {
      const div = document.createElement("div");
      const isRed = card.s === "♥" || card.s === "♦";
      div.className = `playing-card${isRed ? " red" : ""}`;
      div.innerHTML = `<span>${card.r}</span><span>${card.s}</span>`;
      return div;
    }

    function createDeck() {
      const deck = [];
      for (const s of SUITS) {
        for (const r of RANKS) {
          deck.push({ r, s });
        }
      }
      return deck;
    }

    function shuffle(deck) {
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
    }

    function bestOfSeven(cards) {
      let best = null;
      const combos = combinations(cards, 5);
      for (const combo of combos) {
        const score = evaluateFive(combo);
        if (!best || compareScore(score, best) > 0) {
          best = score;
        }
      }
      return best;
    }

    function compareScore(a, b) {
      const len = Math.max(a.length, b.length);
      for (let i = 0; i < len; i++) {
        const ai = a[i] ?? -1;
        const bi = b[i] ?? -1;
        if (ai !== bi) {
          return ai - bi;
        }
      }
      return 0;
    }

    function scoreLabel(score) {
      const [cat, ...rest] = score;
      const label = CATEGORY_LABEL[cat];
      const info = rest.map(v => RANKS[v].replace("T", "10")).join("-");
      return info ? `${label} (${info})` : label;
    }

    function combinations(arr, k) {
      const res = [];
      const curr = [];
      (function backtrack(start, depth) {
        if (depth === k) {
          res.push([...curr]);
          return;
        }
        for (let i = start; i <= arr.length - (k - depth); i++) {
          curr.push(arr[i]);
          backtrack(i + 1, depth + 1);
          curr.pop();
        }
      })(0, 0);
      return res;
    }

    function evaluateFive(cards) {
      const counts = new Map();
      const suitCounts = new Map();
      const values = cards.map(c => RANK_VALUE[c.r]).sort((a, b) => b - a);

      for (const c of cards) {
        counts.set(c.r, (counts.get(c.r) || 0) + 1);
        suitCounts.set(c.s, (suitCounts.get(c.s) || 0) + 1);
      }

      const byCount = [...counts.entries()].map(([r, count]) => ({
        r,
        count,
        v: RANK_VALUE[r]
      })).sort((a, b) => b.count - a.count || b.v - a.v);

      const flushSuit = [...suitCounts.entries()].find(([, n]) => n >= 5)?.[0];
      const flushValues = flushSuit ? cards.filter(c => c.s === flushSuit).map(c => RANK_VALUE[c.r]).sort((a, b) => b - a) : null;
      const straight = detectStraight(values);
      const straightFlush = flushSuit ? detectStraight(cards.filter(c => c.s === flushSuit).map(c => RANK_VALUE[c.r]).sort((a, b) => b - a)) : { ok: false };

      if (straightFlush.ok) {
        return [CAT.STRAIGHTFLUSH, straightFlush.high];
      }

      if (byCount[0].count === 4) {
        const quad = byCount[0].v;
        const kicker = byCount.find(x => x.v !== quad).v;
        return [CAT.QUADS, quad, kicker];
      }

      if (byCount[0].count === 3 && byCount[1] && byCount[1].count >= 2) {
        return [CAT.FULL, byCount[0].v, byCount[1].v];
      }

      if (flushValues) {
        return [CAT.FLUSH, ...flushValues.slice(0, 5)];
      }

      if (straight.ok) {
        return [CAT.STRAIGHT, straight.high];
      }

      if (byCount[0].count === 3) {
        const kickers = byCount.filter(x => x.count === 1).map(x => x.v).sort((a, b) => b - a);
        return [CAT.TRIPS, byCount[0].v, ...kickers.slice(0, 2)];
      }

      if (byCount[0].count === 2 && byCount[1] && byCount[1].count === 2) {
        const p1 = Math.max(byCount[0].v, byCount[1].v);
        const p2 = Math.min(byCount[0].v, byCount[1].v);
        const kicker = byCount.find(x => x.count === 1).v;
        return [CAT.TWOPAIR, p1, p2, kicker];
      }

      if (byCount[0].count === 2) {
        const pair = byCount[0].v;
        const kickers = byCount.filter(x => x.count === 1).map(x => x.v).sort((a, b) => b - a);
        return [CAT.PAIR, pair, ...kickers.slice(0, 3)];
      }

      return [CAT.HIGH, ...values.slice(0, 5)];
    }

    function detectStraight(values) {
      const unique = [...new Set(values)].sort((a, b) => b - a);
      const wheel = [12, 3, 2, 1, 0];
      const isWheel = wheel.every(v => unique.includes(v));
      if (isWheel) {
        return { ok: true, high: 3 };
      }
      for (let i = 0; i <= unique.length - 5; i++) {
        const run = unique.slice(i, i + 5);
        let consecutive = true;
        for (let j = 1; j < run.length; j++) {
          if (run[j - 1] !== run[j] + 1) {
            consecutive = false;
            break;
          }
        }
        if (consecutive) {
          return { ok: true, high: run[0] };
        }
      }
      return { ok: false };
    }

    updatePhase();
    render();
  </script>
</body>
</html>
